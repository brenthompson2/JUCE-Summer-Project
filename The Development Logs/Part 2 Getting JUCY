Brendan Thompson
Development Log 2: Getting JUCY

- Overview ---

This log details my experience learning to code using the JUCE framework on Ubuntu and trying to get my first plugin to build and run

------------------------------------------------
------------------------------------------------

- 08/18/17 ---

Summary:
	- I can't declare and assign values to local temp variables inside getNextAudioBlock without it filling the audio buffer with 0's
	- Figured out to just print variables using std::cout like normal
	- Attempted to make the final sample equal to each individual sample * its weight, but the audio buffer is being filled with 0s
Thoughts:
	- this not being able to declare local temp variables thing has me questioning my existence

- WHY DO VARIABLES KEEP RUINING MY OSCILLATOR!?!?!?!?!?!?!
	- Manually setting the synths works fine
		- synthArray[0] ..."generate"
		- synthArray[1] ..."generate"
	- But introducing variables breaks it
		- int counter = 0;
		- synthArray[counter] ..."generate"
	- Actually, just assignment in general breaks it!!!
		- int counter = 0;
		- synthArray[0] ..."generate"
	- Problem fixes if using global instead of local temp

- How to do additive synthesis?
	- synthWeight = (1 / numSynths)
	- currentSample = sin(angle) * synthWeight
	- finalSample = finalSample + currentSample
	"
 	for (synthCursor = 0; synthCursor < numActiveSynths; synthCursor++){
        (synthArray[synthCursor].nextSample) = (float) std::sin (synthArray[synthCursor].currentAngle);
        (synthArray[synthCursor].nextSample) = ((synthArray[synthCursor].nextSample) * (synthArray[synthCursor].volumeLevel)) * mainVolumeLevel;
        (synthArray[synthCursor].currentAngle) += (synthArray[synthCursor].angleDelta);
        mainNextSample = mainNextSample + ((synthArray[synthCursor].nextSample) * (1 / numActiveSynths));

    }
    buffer[sample] = mainNextSample * mainVolumeLevel;
	"
	- WHY IS THIS ONLY PRODUCING 0's!?!?!?!?

- How to log some debug information to the console
	- DUHHHH
	- Just use std::cout like normal

------------------------------------------------
------------------------------------------------

- 08/17/17 ---

Summary:
	- Worked on AdditiveManual, my additive synth made "manually"
		- One file with everything instead of utilizing oscillator objects or the special audio processing JUCE classes
	- Having a strange error with the oscillator code
Thoughts:
	- This is a similar error as I had 07/24/17 when just the act of declaring an unused variables

- Able to display a select number of instances of the synthComponent oscillator
	- Keeping track of the number of active synths

- Generate Audio function:
	- For some reason I can't keep track of variables declared or given values within getNextAudioBlock() { generateAudio() }
	- The hardcoded version of sine synthesis on one of the oscillators works fine:
		- (synthArray[0].nextSample) = (float) std::sin (synthArray[0].currentAngle);
		- synthArray[0].nextSample = ((synthArray[0].nextSample) * (synthArray[0].volumeLevel)) * mainVolumeLevel;
	- Doing the same code except using an iterator doesn't work:
		- int i = 0;
		- (synthArray[i].nextSample) = (float) std::sin (synthArray[i].currentAngle);
		- synthArray[i].nextSample = ((synthArray[i].nextSample) * (synthArray[i].volumeLevel)) * mainVolumeLevel;
	"
	- Here is the code that I am using
		//for each channel, for each sample, for each active synth, manipulate the sample accordingly
	    void MainContentComponent::generateAudio(const AudioSourceChannelInfo& bufferToFill){
	        const int numChannels = bufferToFill.buffer->getNumChannels();
	        const int numSamples = bufferToFill.numSamples;

	        for (int channel = 0; channel < numChannels; channel++){
	            float* const buffer = bufferToFill.buffer -> getWritePointer (channel, bufferToFill.startSample);
	            float newSample;

	            for (int sample; sample < numSamples; sample++){
	                // Hardcoded White Noise
	                // (synthArray[0].nextSample) = (randomGen.nextFloat() * 2.0f - 1.0f);

	                // Hardcoded Sine Wave
	                (synthArray[0].nextSample) = (float) std::sin (synthArray[0].currentAngle);
	                (synthArray[0].currentAngle) += (synthArray[0].angleDelta);
	                (synthArray[0].nextSample) = ((synthArray[0].nextSample) * (synthArray[0].volumeLevel)) * mainVolumeLevel;
	                buffer[sample] = (synthArray[0].nextSample);

	                // Less Hardcoded Sine Wave ***** FAILS HERE!?!?!?!?
	                // int synthCursor = 0;
	                // (synthArray[synthCursor].nextSample) = (float) std::sin (synthArray[synthCursor].currentAngle);
	                // (synthArray[synthCursor].currentAngle) += (synthArray[synthCursor].angleDelta);
	                // (synthArray[synthCursor].nextSample) = ((synthArray[synthCursor].nextSample) * (synthArray[synthCursor].volumeLevel)) * mainVolumeLevel;
	                // buffer[sample] = (synthArray[synthCursor].nextSample);

	                // Dynamic Sine Waves   *** Doesn't Work ***
	                // buffer[sample] = 0.0f;
	                // for (int i = 0; i < 1; i++){
	                //     (synthArray[i].nextSample) = (float) std::sin (synthArray[i].currentAngle);
	                //     (synthArray[i].currentAngle) += (synthArray[i].angleDelta);
	                //     (synthArray[i].nextSample) = ((synthArray[i].nextSample) * (synthArray[i].volumeLevel)) * mainVolumeLevel;
	                //     buffer[sample] = (synthArray[i].nextSample);
	                // }
	            }
        }
    "
    - This is the same error I had on 07/24/17
    "
		- This Works:
            buffer[sample] = (randomGen.nextFloat() * 0.25f - 0.125f);
		- This Doesn't Work:
			float newValue = (randomGen.nextFloat() * 0.25f - 0.125f);
            buffer[sample] = newValue;
    "
    - I worked around this last time by removing temps or making them global

------------------------------------------------
------------------------------------------------

- 08/14/17 ---

Summary:
	- I got sick of dealing with their Audio Processing Classes
	- I made AdditiveManual, an additive synthesizer made as just a big .cpp and a .h with everything included.
		- UI, Synth Objects, Graph
Thoughts:
	- It felt amazing to just go back to my C roots and cram it out somewhat lightweight.
	- I could definitely pass some of the functions if I created an actual Synth Object but IDK how I would process the UI elements
		- How would the UI on the main page tell the synth what frequency the slider is at?
		- In paint()?
		- In the sliderValueChanged fn call the fn from the Synth Object

- AdditiveManual = One large .cpp & .h that controls everything
	1) Create a synthComponent struct:
		// Structs
	    struct synthComponent
	    {
	    	bool isActive;

	    	// Volume & Frequency
	    	Slider volumeSlider;
	    	Label volumeLabel;
			float volumeLevel;
	    	Slider frequencySlider;
	    	Label frequencyLabel;
	    	double currentFrequency;

			// Audio Synthesis Members
		    float nextSample;
	    	double currentAngle;
	    	double angleDelta;

	    	// UI
	    	TextButton contentArea;
	    };
	2) Declare a synthArray of type synthComponent:
		synthComponent synthArray[MAX_SYNTHS];
	3) Instantiate all the elements within the constructor
		initSynths();
	4) Draw the UI elements in resized()
		- When running, must resize before drawing elements (doesn't draw originally)
		- Have to change frequency before playing sound
	5) Pass the audio to the synths and have them add together their output
		generateAudio(const AudioSourceChannelInfo& bufferToFill);


------------------------------------------------
------------------------------------------------

- 08/06/17 ---

Summary:
	- Started to make the AdditiveSynth without all those classes
	- Struggling to access a pointer to an object of my SynthForAdding class
		- Attempting to set the bounds equal to the bounds of a rectangle
Thoughts:
	- Need to stop using TextButtons as UI elements

- Interesting: an AudioAppComponent, the base class for MainComponent, has a public attribute of type AudioDeviceManager called deviceManager



------------------------------------------------
------------------------------------------------

- 08/05/17 ---

Summary:
	- Worked on the AudioManagementTemplate
	- Thinking about ditching the AudioDeviceManager, AudioProcessorPlayer, and AudioProcessorGraph since my MainComponent can pretty much be its own data structure to manage what the graph would
Thoughts:
	- I think the AudioManagementTemplate might be unnecessary for just trying to create a synthesizer with components such as a few oscillators, maybe an lfo, high and low pass filters, ADSR control, etc.
	- Perhaps I will have to revisit the AudioDeviceManager, AudioProcessorPlayer, and AudioProcessorGraph again in the future, but my program seems like it should pretty much be its own data structure to manage the flow of the individual components
	- It might make it harder to create an XML that stores preset data for the whole synthesizer

- The AudioManagementTemplate:
	- MainComponent =
	- BasicAudioProcessor:
	- BasicAudioProcessorEditor:

	- Creating the mainAudioDeviceManager:
		1) Declare in header as private member:
			- AudioDeviceManager mainAudioDeviceManager;
		2) Initialize in constructor:
			- mainAudioDeviceManager.initialiseWithDefaultDevices(NUMBER_INPUT_CHANNELS, NUMBER_OUTPUT_CHANNELS);

	- Creating the mainAudioProcessorPlayer & Linking to mainAudioDeviceManager

	- Linking the Processor w/ the Editor:
		A) BasicAudioProcessor.h:
			1) inherit from AudioProcessor
			2) override the Editor functions:
				- bool hasEditor() const override 					{return true; }
				- AudioProcessorEditor* createEditor() override;
		B) BasicAudioProcessor.cpp:
			1) include both headers (processor & editor)
			2) create the editor:
				- AudioProcessorEditor* BasicAudioProcessor::createEditor(){ return new BasicAudioProcessorEditor (*this);}
		C) BasicAudioProcessorEditor.h:
			1) inherit from AudioProcessorEditor
			2) add processor as constructor parameter:
				- BasicAudioProcessorEditor (BasicAudioProcessor&);
		E) BasicAudioProcessorEditor.cpp:
			1) include both headers (processor & editor)
			2) Construct the AudioProcessorEditor:
				- BasicAudioProcessorEditor::BasicAudioProcessorEditor(BasicAudioProcessor& owner) : AudioProcessorEditor (owner)	{ }




------------------------------------------------
------------------------------------------------

- 08/03/17 ---

Summary:
	- Conducted more research into the classes used for managing Audio:
		- AudioDeviceManager, AudioProcessorPlayer, AudioProcessorGraph, AudioProcessor, AudioProcessorEditor
	- Worked on the AudioManagementTemplate project that utilizes these main audio classes
Thoughts:
	- The Audio plugin host example JUCE project is actually for hosting VSTs that I create
	- I think the highest up the class ladder that I will need to go is the AudioProcessorGraph which manages multiple processors
		- I bet only super elaborate programs need an AudioDeviceManager which manages multiple players/graphs

- AudioProcessorGraph:
	- ../JUCE/examples/audio plugin host/Source/FilterGraph
		- example also uses XML Methods for saving presets
		- Side Note: I think the Audio Plugin Host is used for hosting / testing VST plugins that are created with JUCE
		1) Private Variable in header: AudioProcessorGraph graph;
		2) Public Method in header: AudioProcessorGraph& getGraph() noexcept         { return graph; }
			- actually I think this is just a method and does nothing for instantiation
			- see: FilterIOConfigurationWindow::~FilterIOConfigurationWindow
		3) Add a listener in the constructor: graph.addListener(this);
		4) free the graph in the destructor: graph.clear();
		5) to get a node: graph.getNode(index);
	- Where is the graph instantiated!?!?!?
	- https://www.juce.com/doc/classAudioProcessorGraph
	- an APG "Node" is a Processor (addNode() to attach processors to the graph)

- AudioDeviceManager
	- https://www.juce.com/doc/classAudioDeviceManager
		-"To use an [ADM], create one, and use initialise() to set it up. Then call addAudioCallback() to register your audio callback with it, and use that to process your audio"
		- multiple callbacks = same input, summed output

- AudioProcessor
	- ../JUCE/examples/audio plugin host/Source/GraphEditorPanel
	- AudioProcessor* processor = node->getProcessor();
		- node from graph
    - AudioProcessorEditor* ui = nullptr;
    ***** ../JUCE/examples/audio plugin demo/PluginProcessor.cpp
	- Example Constructor:
	    "
	    JuceDemoPluginAudioProcessor::JuceDemoPluginAudioProcessor()
		    : AudioProcessor (getBusesProperties()),
			    lastUIWidth (400),
			    lastUIHeight (200),
			    gainParam (nullptr),
			    delayParam (nullptr),
			    delayPosition (0)
		{
		    lastPosInfo.resetToDefault();

		    // This creates our parameters. We'll keep some raw pointers to them in this class,
		    // so that we can easily access them later, but the base class will take care of
		    // deleting them for us.
		    addParameter (gainParam  = new AudioParameterFloat ("gain",  "Gain",           0.0f, 1.0f, 0.9f));
		    addParameter (delayParam = new AudioParameterFloat ("delay", "Delay Feedback", 0.0f, 1.0f, 0.5f));

		    initialiseSynth();
		}
		"
	- Example Processor:
		1) Private Method "process":
			"
			template <typename FloatType>
			JuceDemoPluginAudioProcessor::process(AudioBuffer<FloatType>& buffer,
							MidiBuffer& midiMessages,
							AudioBuffer<FloatType>& delayBuffer);
			"
		2) Override processBlock function:
			"
			void processBlock (AudioBuffer<double>& buffer, MidiBuffer& midiMessages) override
    		{
		        process (buffer, midiMessages, delayBufferDouble);
		    }
		    "
		3) Declare Private DelayBuffer Member for future use:
			AudioBuffer<double> delayBufferDouble;

- AudioProcessorEditor:
	- instantiated by the AudioProcessor


- AudioProcessorPlayer

- Creating my AudioManagementTemplate project
	- The Files:
		A) Main: Creates the main JUCE Application
		B) MainComponent:
			- AudioDeviceManager & AudioProcessorGraph
			- Xml
			- #include "BasicAudioProcessorEditor.h"
			- #include "BasicAudioProcessor.h"
		C) BasicAudioProcessor:
			- AudioProcessor
			- #include "BasicAudioProcessorEditor.h"
		D) BasicAudioProcessorEditor:
			- AudioProcessorEditor

	- Creating an AudioDeviceManager:
		1) In MainComponent.h declare the object:
			AudioDeviceManager MainAudioDeviceManager();
		2) In MainComponent.cpp instantiate the object:
			- How?

	- Creating an AudioProcessorPlayer:
		1) Somehow instantiate the graph and attach it to the AudioDeviceManager:
		2) Set the processor to the graph:
			mainAudioPlayer.setProcessor(mainAudioGraph)

	- Creating an AudioProcessorGraph:
		1) Declare the graph as a private member:
			AudioProcessorGraph mainAudioGraph;
		2) Somehow instantiate the graph and attach it to the AudioProcessorPlayer:
		3) Add a processor to the graph (this is a total guess):
			"
			BasicAudioProcessor mainAudioProcessor = new BasicAudioProcessor();
	        Node* tempNodePointer = graph.addNode(mainAudioProcessor, 0);
	        if (tempNodePointer == nullptr){
	            // Unable to add the node to the graph
	        }
	        "

	- Creating an AudioProcessor:
		1) Private Template fn for processing audio:
			"
			template <typename FloatType>
			void process (AudioBuffer<FloatType>& buffer, MidiBuffer& midiMessages,	AudioBuffer<FloatType>& delayBuffer);
		2) Override public processBlock to call private process:
			"
			void processBlock (AudioBuffer<double>& buffer, MidiBuffer& midiMessages) override
    		{
		        process (buffer, midiMessages, delayBufferDouble);
		    }
		    "
		3) Need private member delayBufferDouble for creating a delay:
    		AudioBuffer<double> delayBufferDouble;
    	4) Private Function to createEditor:
    		"
    		AudioProcessorEditor* BasicAudioProcessor::createEditor(){
    			return new BasicAudioProcessorEditor;
    		}
    		"
    	5) Override the "hasEditor()" method in the header
    		bool hasEditor() const override {return true; }
    	6) See AudioProcessorGraph #

    - Creating an AudioProcessorEditor
    	1) See AudioProcessor #4 & #5


------------------------------------------------
------------------------------------------------

- 07/28/17 ---

Summary:
	- Researched some digital signal processing information
	- Utilized the AudioProcessor and AudioProcessorEditor Class to communicate date between the processor and the editor
		- Have been able to compile the project but don't know how to instantiate those two objects
	- Found and analyzed an advanced juce tutorial from February 2013: https://artandlogic.com/2013/02/developing-audio-applications-with-juce-part-1/
Thoughts:
	- The AudioProcessor and AudioProcessorEditor classes are awesome ways to communicate data between the MainAudioProcessor code and the UserInterface
	- I need to utilize AudioProcessorGraph to manage a series of AudioProcessors


- Archive of DSP code: www.musicdsp.org
- I need to find some more example JUCE applications

- Managing the data with the ValueTree & AudioProcessorValueTreeState class
	- https://www.juce.com/doc/tutorial_audio_processor_value_tree_state
	- AudioProcessorValueTreeState is a ValueTree with utility child classes for connecting parameters directly to UI components
		- Need to look into attaching it to the UI with Listener or SliderAttachment
		- Converts easily to XML for saving presets
	- a AudioProcessorValueTreeState object must be:
		A) attached to only one processor
		B) have the same lifetime as the processor
	- This didn't work for me naturally because MainComponent.cpp inherits from AudioAppComponent, not AudioProcessor
	0) In the MainAudioProcessor: inherit from AudioProcessor:
		"class MainAudioProcessor : public AudioProcessor"
	1) declare the value tree object in the processor class: "AudioProcessorValueTreeState parameters" in the header
	2) set it up in the constructor with a reference to the AudioProcessor subclass and a pointer to an UndoManager
		"
		MainComponent::MainComponent()
	    :
	        ...
	        parameters (*this, nullptr)
	    {
	    "
	3) Configure your parameters in AP with createAndAddParameter()
		"
		parameters.createAndAddParameters("volumeLevel", // ID such as a variable name
                                        "Volume",       // name for display
                                        String(),       // label for suffix (dB, Hz)
                                        NormalisableRange<float> (0.0f, MAX_VOLUME),
                                        0.25,           // default value
                                        nullptr, nullptr);	// for converting between text and the value
        "
    4) Initialize the object in the AP constructor:
    	"parameters.state = ValueTree (Identifier ("AdditiveSynth"));"
    5) In the UI: inherit from AudioProcessorEditor:
    	"class UserInterface : public AudioProcessorEditor"
    	- which also inherits from the Component Class
    6) Declare as private members a pointer to the value tree and also the attachment objects:
    	"
    	AudioProcessorValueTreeState& valueTreeState;
	    Slider mainVolumeSlider;
	    Label mainVolumeLabel;
	    ScopedPointer<AudioProcessorValueTreeState::SliderAttachment> volumeAttachment;
	    "
    7) Link the Processor with the Editor in the UI constructor & Initialize the values:
		"
		UserInterface(AudioProcessor& parent, AudioProcessorValueTreeState& parentVTS)
			: AudioProcessorEditor (parent),
			valueTreeState (parentVTS)
		{
		"
	8) Attach the sliders to the valueTree parameters in the UI constructor:
		"
		volumeAttachment = new AudioProcessorValueTreeState::SliderAttachment (valueTreeState,
													"volumeLevel", mainVolumeSlider);
		"
	9) In the MainAudioProcessor header: instantiate the UserInterface by overwriting the createEditor function and changing hasEditor()
		"
		AudioProcessorEditor* createEditor() override { return new UserInterface (*this, parameters); }
		bool hasEditor() const override 		{return true;	}
		"

- The source files & How I am managing data communication between them:
	A) Main.cpp
	B) MainComponent.cpp
		- Inherits from AudioAppComponent
		- used for I/O
	C) AudioProcessor.cpp
		- Inherits from AudioProcessor
		- Use AudioProcessorValueTreeState to store parameters
			- inherits from Listener and SliderAttachment
	D) UserInterface.cpp
		- Inherits from AudioProcessorEditor
	- Parameters passed back and forth between C & D using the AudioProcessorValueTreeState

- Advanced JUCE Tutorial from Feb 2013:
	- https://artandlogic.com/2013/02/developing-audio-applications-with-juce-part-1/
	1) The Classes that make up an Audio Application
		A) AudioDeviceManager:
			- The application should have a single instance
			- encapsulates all pertinent audio and midi hardware available
			- for audio to start flowing, need to pass this object a pointer to another object that implements the AudioIODeviceCallback interface
			- Once the callback is added to the device manager it is called repeatedly with buffers of audio & midi data that needs to be processed
		B) AudioProcessor:
			- Used for processingBlocks of audio
		C) AudioProcessorGraph:
			- is an AudioProcessor that holds other AudioProcessors and connects their I/O in arbitrary topologies
			***** Rewarding to spend time studying this class
		D) AudioProcessorPlayer:
			- Glue between ADM and APG
			- AudioIODeviceCallback object that can be passed to the AudioDeviceManager
			- Has an AudioProcessor
			*** Create an instance of AudioProcessorGraph and pass it to the AudioProcessorPlayer::setProcessor()
		E) AudioProcessorGraph::AudioGraphIOProcessor
			- can instantiate as special I/O nodes for putting audio into the processor graph or sending it back out

------------------------------------------------
------------------------------------------------

- 07/27/17 ---

Summary:
	- Tried to fix the problem from last time where float assignment cause no sound to play from the synth
		(float unusedFloat = 0.25f;)
		- ended up making the temporary variable into a private member
	- Made a working sine wave oscillator
	- Attempting to get the code under MainComponent to work with the UserInterface files
Thoughts:
	- I have pretty much reached the end of the JUCE tutorials. It looks like I need to learn more digital signal processing

- Troubleshooting the inability to do assignment:
	**** Would the program work if I make the temporary "nextSample" a global member variable?
		- Terrible in theory! Silly to make a temp variable into a class member
		- This solution worked with nextSample and volumeLevel both being class private member variables
		"
		nextSample = ((randomGen.nextFloat() * 2.0f - 1.0f) * volumeLevel);
        buffer[sample] = nextSample;
        "
		- This makes me think it has something to do with allocating memory on the audio thread
		- Lets see if I declare the variable in prepareToPlay() if it pops back off the stack out of scope...
			- Yup, out of scope
		- I guess I am going to have to work with this ugly fix until I understand whats going on

- Turning it into a sine wave generator:
	- https://www.juce.com/doc/tutorial_sine_synth
	- Simulating a sine wave:
		- use std::sin()
			- "Most synthesis applications and plug-ins are likely not to use std::sin() functions"
			- see: wavetable synthesis juce tutorial
		- store the state by using the currentPhaseAngle and the size of the change (delta)
			- dependant on sample rate and desired frequency
	- The Code:
		1) Create some member variables in the header:
			double currentSampleRate, currentAngle, angleDelta, desiredFrequency;
		2) Write a function that updates the angleDelta
			"
			void updateAngleDelta(){
		        // number of cycles necessary per each output sample, multiplied by length of sine wave cycle (2pi radians)
		        const double cyclesPerSample = desiredFrequency / currentSampleRate;
		        angleDelta = cyclesPerSample * 2.0 * double_Pi;
	    	}
			"
		3) Store the output sample rate and initialize angleDelta in prepareToPlay(int samplesPerBlockExpected, double sampleRate)
			"
			currentSampleRate = sampleRate;
			updateAngleDelta();
			"
		4) Update angleDelta whenever the frequency slider is moved in the SliderValueChanged() overwriten Listener function
			"
		    if (slider == &frequencySlider){
		    	desiredFrequency = frequencySlider.getValue();
		        if (currentSampleRate > 0.0){
		            updateAngleDelta();
		        }
		    }
		    "
		5) Use the value to manipulate the value of nextSample:
			"
			nextSample = (float) std::sin (currentAngle);	// calculate the sine fn for the current angle
            currentAngle += angleDelta;	// increment the angle for the next sample
            buffer[sample] = nextSample * volumeLevel;
            "
        6) Setup the frequency Slider in the main constructor
        	- skew makes it feel more natural since the change is applied logarithmicly (500 is now the midpoint)
        		frequencySlider.setSkewFactorFromMidPoint(500.0);
   	- Smoothing out the changes in frequency to reduce artifacts
   		1) Create another member variable, double currentFrequency;
   		2) Initialize the values in the constructor in an interesting way:
   			"
			MainContentComponent::MainContentComponent()
			:
			    currentSampleRate (0.0),
			    currentAngle(0.0),
			    angleDelta(0.0),
			    currentFrequency(500.0),
			    desiredFrequency(currentFrequency)
			{
			    setSize (800, 600);
			    //...
   			"
   		3) Change the way synthesis works:
   			- if (desiredfrequency != currentFrequency) then calculate the increment, apply it, and updateAngleDelta()
   			- else do what you did before
   		4) Stop sliderValueChanged() frequencySlider part from calling updateAngleDelta()
   		- Problem: Only getting sound when changing frequency, not constantly
   			- scrapping most of this but keeping the initialized values idea
   			- I am sure I will have to revisit this when I actually need to smooth something out like this

- The Wavetable Synthesis tutorial doesn't exist yet...

- Advanced UI Techniques:
	- https://www.juce.com/doc/tutorial_rectangle_advanced
	- I am going to try to code this in UserInterface.cpp and link it up with the code under MainComponent.cpp
	- Layout by subdividing rectangles:


------------------------------------------------
------------------------------------------------

- 07/24/17 ---

Summary:
	- Started my first project: an additive synthesizer
	- Create a white noise generator
	- Attempted to control the volume with a slider but for some reason the act of assigning a value to a float causes the audio to not play. I can create a variable, I just can't assign a value to it
Thoughts:
	- I am excited to turn this white noise generator into a sine wave generator
	- If I can't assign a value to a float (float unusedFloat = 0.25f;) then idk what the hell to do
Take Aways:
	- Code of a synthesizer
	- Random class used (random num between 0 & 1)

- I don't have any way to host audio plugins in linux. I need to check out the Introjucer

- Attempting to get white noise to generate
	- https://www.juce.com/doc/tutorial_simple_synth_noise
	- Easy enough: Basically you access the Audio Buffer stored in bufferToFill, an object of type AudioSourceChannelInfo
		- Then for each channel just go through every sample and fill it with random values
	"
	// For every channel in the buffer, fill every sample with random values (random is between 0-1)
    Random randomGen;
    int numChannels = bufferToFill.buffer->getNumChannels();
    int numSamples = bufferToFill.numSamples;
    for (int channel = 0; channel < numChannels; channel++){
        float* const buffer = bufferToFill.buffer -> getWritePointer (channel, bufferToFill.startSample);
        for (int sample; sample < numSamples; sample++){
            buffer[sample] = (randomGen.nextFloat() * 0.25f - 0.125f);
        }
    }
	"

- Controlling the output of the synthesizer:
	- https://www.juce.com/doc/tutorial_synth_level_control
	- Well I don't want to use their sample project so I am going to try to make my own
	- Getting a slider in there:
		- From my JUCE Development notes on The Audio Programmer's 4th episode:
		"
		- Creating a dial (slider)
			1) Declaration in MainComponent.h = Slider dial1;
			2) addAndMakeVisable(dial1); in MainComponent constructor
			3) chose the type (slider, dial, etc) = dial1.setSliderStyle(Slider::SliderStyle::Rotary); 6:40
			4) setTextBoxStyle (Slider::TextEntryBoxPosition::TextBoxBelow, readOnly = false so we can edit by typing, width, height);
			5) synch coordinates with parent = dial1.setBounds(getLocalBounds());
		"

	**** Stupid Error: If I assign a value to a float anywhere in the fn it stops the audio from being produced
		- This Works:
            buffer[sample] = (randomGen.nextFloat() * 0.25f - 0.125f);
		- This Doesn't Work:
			float newValue = (randomGen.nextFloat() * 0.25f - 0.125f);
            buffer[sample] = newValue;
        - This Still Outputs White Noise:
	        "
	        float unusedFloat;
		    // For every channel in the buffer, fill every sample with random values
		    Random randomGen;
		    int numChannels = bufferToFill.buffer->getNumChannels();
		    int numSamples = bufferToFill.numSamples;
		    for (int channel = 0; channel < numChannels; channel++){
		        float* const buffer = bufferToFill.buffer -> getWritePointer (channel, bufferToFill.startSample);
		        for (int sample; sample < numSamples; sample++){
		            buffer[sample] = (randomGen.nextFloat() * 2.0f - 1.0f);
		        }
		    }
		    "
		- This Doesn't Work:
	        float unusedFloat = 2.0f;
		    // For every channel in the buffer, fill every sample with random values
		    Random randomGen;
		    int numChannels = bufferToFill.buffer->getNumChannels();
		    int numSamples = bufferToFill.numSamples;
		    for (int channel = 0; channel < numChannels; channel++){
		        float* const buffer = bufferToFill.buffer -> getWritePointer (channel, bufferToFill.startSample);
		        for (int sample; sample < numSamples; sample++){
		            buffer[sample] = (randomGen.nextFloat() * 2.0f - 1.0f);
		        }
		    }
		    "
		- This Doesn't Work:
			"
	        float unusedFloat;
	        unusedFloat = 2.0f;
		    ...
		    "
		- Their code from the tutorials doesnt work either:
			- const float level = (float) MainVolumeSlider.getValue(); (synth_level_control)
		- Without even using the variable, just the act of assigning it a value causes the audio to stop being produced. WTF

    - Listening to slider values:
		- https://www.juce.com/doc/tutorial_slider_values
    	1) add "public Slider::Listener" to the list of child components of MainContentComponent in the header
    	2) add "void sliderValueChanged (Slider* slider) override;"" to the header to overide this Listener fn
    	3) overide the sliderValueChange function in the .cpp file
    		- "void MainContentComponent::sliderValueChanged (Slider* slider){..."
    	4) attach the listener to the object during the contructor: "MainVolumeSlider.addListener(this);""
    	5) In sliderValueChanged, use MainVolumeSlider.getValue();

    - Side Note: attach labels to components
    	- MainVolumeLabel.attachToComponent (&MainVolumeSlider, false);	// true = left, false = above

------------------------------------------------
------------------------------------------------

- 07/23/17 ---

Summary:
	- Researched Advanced C++ techniques and started taking notes on an online book
	- Followed along with a youtube tutorial
	- Played around with the basic file structure
Thoughts:
	- I am so excited to finally start getting things off the ground!

- Researched Advanced C++ Topics:
	- Website cplusplus.bordoon.com/cplusplusadvice.html
	- Online textbook "Tips and Tricks of the C++ Professionals" from www.bordoon.com/book/index.html
- Let's Code!
- I am going to start by following along with the 6th tutorial by The Audio Programmer
	- This was the last tutorial in the series, some decent beginner work, but I still don't know anything about manipulating the Audio Buffer

















